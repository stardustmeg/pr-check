name: AI PR Review (Anthropic)

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number
      model:
        description: 'AI model to use'
        required: false
        default: 'claude-sonnet-4-20250514'
        type: choice
        options:
          - claude-sonnet-4-20250514
          - claude-opus-4-20250514
          - claude-haiku-4-20250514

jobs:
  pr-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get PR details and diff
        id: pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          pr_data=$(gh pr view ${{ inputs.pr_number }} --json title,body,headRefOid)
          echo "title=$(echo "$pr_data" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "body=$(echo "$pr_data" | jq -r '.body // ""')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$pr_data" | jq -r '.headRefOid')" >> $GITHUB_OUTPUT

          gh pr diff ${{ inputs.pr_number }} > pr_diff.txt

          if [ $(wc -c < pr_diff.txt) -gt 50000 ]; then
            head -c 50000 pr_diff.txt > pr_diff_truncated.txt
            echo "TRUNCATED=true" >> $GITHUB_OUTPUT
            mv pr_diff_truncated.txt pr_diff.txt
          else
            echo "TRUNCATED=false" >> $GITHUB_OUTPUT
          fi

      - name: Annotate diff with file paths and line numbers
        run: |
          cat > annotate_diff.awk << 'AWKEOF'
          BEGIN { file = ""; nl = 0 }
          /^diff --git/ {
            n = split($0, parts, " ")
            file = parts[n]
            sub(/^b\//, "", file)
            next
          }
          /^(---|\+\+\+|index |old mode|new mode|similarity|rename|copy|new file|deleted file)/ { next }
          /^@@/ {
            s = $3
            sub(/\+/, "", s)
            sub(/,.*/, "", s)
            nl = int(s)
            print ""
            print "=== " file " ==="
            next
          }
          /^\+/ {
            printf "[%s:%d] %s\n", file, nl, $0
            nl++
            next
          }
          /^-/ {
            printf "[REMOVED] %s\n", $0
            next
          }
          {
            nl++
          }
          AWKEOF
          awk -f annotate_diff.awk pr_diff.txt > annotated_diff.txt

      - name: Run AI review
        id: review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          cat > system_prompt.txt << 'SYSPROMPT'
          You are an expert code reviewer. You will receive a pull request diff
          where each added/changed line is annotated as [filepath:line_number].

          Return your review as a **single JSON object** with this exact schema:

          {
            "summary": "<markdown-formatted overall review>",
            "inline_comments": [
              {
                "path": "relative/file/path.ext",
                "line": <integer - must match a [filepath:line] annotation>,
                "body": "Your specific, actionable comment"
              }
            ]
          }

          Rules:
          - "path" and "line" MUST exactly match values from the [filepath:line] annotations.
          - Only comment on added/changed lines (those with [filepath:line] annotations).
          - Keep inline comments specific, actionable, and concise.
          - Focus on: bugs, security issues, performance problems, correctness, and maintainability.
          - Do NOT add praise-only inline comments - only comment where there is something actionable.
          - If nothing warrants an inline comment, return an empty "inline_comments" array.
          - "summary" should cover: overview of changes, strengths, issues, suggestions, security, and testing.
          - Return ONLY the raw JSON object. No markdown fences. No surrounding text.
          SYSPROMPT

          cat > user_prompt.txt << EOF
          PR Title: ${{ steps.pr.outputs.title }}
          PR Description: ${{ steps.pr.outputs.body }}

          Annotated Diff:
          EOF
          cat annotated_diff.txt >> user_prompt.txt

          SYSTEM_JSON=$(jq -Rs . < system_prompt.txt)
          USER_JSON=$(jq -Rs . < user_prompt.txt)

          # Anthropic API: system prompt is a top-level field, not a message.
          # Prefill assistant response with "{" to force JSON output.
          response=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "{
              \"model\": \"${{ inputs.model }}\",
              \"max_tokens\": 4096,
              \"temperature\": 0.2,
              \"system\": $SYSTEM_JSON,
              \"messages\": [
                {\"role\": \"user\", \"content\": $USER_JSON},
                {\"role\": \"assistant\", \"content\": \"{\"}
              ]
            }")

          echo "$response" > api_response.json

          # Handle API errors
          if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
            error_msg=$(echo "$response" | jq -r '.error.message')
            echo "::error::Anthropic API error: $error_msg"
            printf '{"summary":"API Error: %s","inline_comments":[]}' "$error_msg" > review.json
            exit 0
          fi

          # Anthropic response shape: .content[0].text
          content=$(echo "$response" | jq -r '.content[0].text // ""')

          if echo "$content" | jq . > /dev/null 2>&1; then
            echo "$content" > review.json
          else
            cleaned=$(echo "$content" | sed '/^```/d')
            if echo "$cleaned" | jq . > /dev/null 2>&1; then
              echo "$cleaned" > review.json
            else
              echo "::warning::AI response was not valid JSON - falling back to plain comment"
              jq -n --arg s "$content" '{"summary": $s, "inline_comments": []}' > review.json
            fi
          fi

          if [ "${{ steps.pr.outputs.TRUNCATED }}" == "true" ]; then
            jq '.summary += "\n\n---\n**Note**: The diff was truncated due to size. This review covers the first ~50KB of changes."' \
              review.json > tmp.json && mv tmp.json review.json
          fi

      - name: Post review with inline comments
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          summary=$(jq -r '.summary' review.json)
          comment_count=$(jq '.inline_comments | length' review.json)

          if [ "$comment_count" -gt 0 ]; then
            jq --arg sha "${{ steps.pr.outputs.head_sha }}" '{
              body: .summary,
              event: "COMMENT",
              commit_id: $sha,
              comments: [.inline_comments[] | {path, line, body, side: "RIGHT"}]
            }' review.json > review_payload.json

            echo "Submitting review with $comment_count inline comment(s)..."

            if gh api "repos/${{ github.repository }}/pulls/${{ inputs.pr_number }}/reviews" \
                 --method POST --input review_payload.json > review_result.json 2>&1; then
              echo "Review with inline comments posted to PR #${{ inputs.pr_number }}"
            else
              echo "::warning::Inline comments rejected by GitHub API - posting as regular comment"
              cat review_result.json

              {
                echo "$summary"
                echo ""
                echo "---"
                echo "### Inline Comments"
                echo ""
                jq -r '.inline_comments[] | "- **`\(.path):\(.line)`** - \(.body)"' review.json
              } > fallback_comment.md

              gh pr comment ${{ inputs.pr_number }} --body-file fallback_comment.md
              echo "Review posted as regular comment (fallback) to PR #${{ inputs.pr_number }}"
            fi
          else
            echo "$summary" | gh pr comment ${{ inputs.pr_number }} --body-file -
            echo "Summary posted to PR #${{ inputs.pr_number }}"
          fi

      - name: Upload review artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ai-review-anthropic-pr-${{ inputs.pr_number }}
          path: |
            review.json
            api_response.json
            annotated_diff.txt
          retention-days: 30
