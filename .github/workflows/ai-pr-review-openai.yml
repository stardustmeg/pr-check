name: AI PR Review (OpenAI)

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number
      model:
        description: 'OpenAI model to use'
        required: false
        default: 'gpt-5.2'
        type: choice
        options:
          - gpt-5.2
          - gpt-5-mini
          - gpt-4.1
      language:
        description: 'Review language'
        required: false
        default: 'Russian'
        type: choice
        options:
          - Russian
          - English

jobs:
  pr-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get PR details and diff
        id: pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          pr_data=$(gh pr view ${{ inputs.pr_number }} --json title,body,headRefOid)
          echo "title=$(echo "$pr_data" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$pr_data" | jq -r '.headRefOid')" >> $GITHUB_OUTPUT

          # body can contain newlines â€” must use heredoc delimiter for GITHUB_OUTPUT
          {
            echo "body<<BODY_EOF"
            echo "$pr_data" | jq -r '.body // ""'
            echo "BODY_EOF"
          } >> $GITHUB_OUTPUT

          gh pr diff ${{ inputs.pr_number }} > pr_diff.txt

          if [ $(wc -c < pr_diff.txt) -gt 50000 ]; then
            head -c 50000 pr_diff.txt > pr_diff_truncated.txt
            echo "TRUNCATED=true" >> $GITHUB_OUTPUT
            mv pr_diff_truncated.txt pr_diff.txt
          else
            echo "TRUNCATED=false" >> $GITHUB_OUTPUT
          fi

      - name: Annotate diff with file paths, line numbers, and diff positions
        run: |
          # This awk script produces two outputs:
          # 1. annotated_diff.txt  - for the AI to read (human-friendly)
          # 2. position_map.json   - maps "file:line" -> diff position for the GitHub API
          #
          # GitHub's Reviews API uses "position" (1-based offset from the @@ header,
          # continuing across hunks per file). The "line"/"side" params are unreliable.
          cat > annotate_diff.awk << 'AWKEOF'
          BEGIN {
            file = ""; nl = 0; pos = 0
            printf "{" > "position_map.json"
            first = 1
          }
          /^diff --git/ {
            n = split($0, parts, " ")
            file = parts[n]
            sub(/^b\//, "", file)
            pos = 0
            next
          }
          /^(---|\+\+\+|index |old mode|new mode|similarity|rename|copy|new file|deleted file)/ { next }
          /^@@/ {
            s = $3
            sub(/\+/, "", s)
            sub(/,.*/, "", s)
            nl = int(s)
            print ""
            print "=== " file " ==="
            next
          }
          /^\+/ {
            pos++
            printf "[%s:%d pos:%d] %s\n", file, nl, pos, $0
            # Write to position map
            key = file ":" nl
            if (!first) printf "," >> "position_map.json"
            printf "\"%s\":%d", key, pos >> "position_map.json"
            first = 0
            nl++
            next
          }
          /^-/ {
            pos++
            printf "[REMOVED pos:%d] %s\n", pos, $0
            next
          }
          {
            # Context line
            pos++
            nl++
          }
          END {
            printf "}" >> "position_map.json"
          }
          AWKEOF
          awk -f annotate_diff.awk pr_diff.txt > annotated_diff.txt

          echo "::group::Debug - position_map.json"
          cat position_map.json | jq .
          echo "::endgroup::"

      - name: Run AI review
        id: review
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cat > system_prompt.txt << 'SYSPROMPT'
          You are a senior software engineer performing a code review. You think
          critically about correctness, security, and design. You will receive a
          pull request diff where added/changed lines are annotated as
          [filepath:line_number pos:N].

          ## Review priorities (highest to lowest)
          1. Correctness bugs, crashes, data loss
          2. Security vulnerabilities (injection, auth bypass, secret exposure)
          3. Error handling gaps (unhandled nulls, missing try/catch, silent failures)
          4. Logic issues, race conditions, edge cases
          5. Performance problems (N+1 queries, unnecessary allocations, blocking calls)
          6. API contract issues (breaking changes, missing validation)
          7. Maintainability and readability

          ## Output format
          Return a single JSON object:
          {
            "summary": "<markdown string>",
            "inline_comments": [
              {
                "path": "file/path.ext",
                "line": <integer from [filepath:line_number] annotation>,
                "severity": "critical|warning|suggestion|nitpick",
                "body": "Explanation of the problem, its impact, and a concrete fix"
              }
            ]
          }

          ## Summary structure
          Write the summary in markdown with these sections:
          - **Intent**: 1-2 sentences on what this PR aims to do
          - **Risk assessment**: What could go wrong in production if merged as-is
          - **Key findings**: Most important issues grouped by severity
          - **Verdict**: One of: APPROVE, APPROVE WITH SUGGESTIONS, REQUEST CHANGES

          ## Inline comment rules
          - CRITICAL: Must be fixed before merge (bugs, security, data loss)
          - WARNING: Likely problems that should be addressed (missing error handling, logic gaps)
          - SUGGESTION: Better approaches, cleaner patterns, performance wins
          - NITPICK: Minor style/naming issues (max 2 total, skip if nothing important)

          Quality standards for each comment:
          - State the PROBLEM, explain the IMPACT, suggest a concrete FIX
          - If a pattern repeats across lines, comment once and note "same issue at lines X, Y"
          - Do NOT comment just to show you reviewed the code
          - Do NOT flag correct-but-unconventional code as a bug; use "suggestion" severity
          - Do NOT add praise-only comments
          - If nothing warrants an inline comment, return an empty array

          ## Hard constraints
          - "path" and "line" must exactly match [filepath:line_number] annotations
          - Return ONLY raw JSON. No markdown fences. No text outside the JSON object.
          - Write ALL review text (summary and inline comment bodies) in **$REVIEW_LANG**.
            JSON keys ("summary", "inline_comments", "path", "line", "severity", "body")
            must remain in English. Only the human-readable text values change language.
          SYSPROMPT
          sed -i "s|\$REVIEW_LANG|${{ inputs.language }}|g" system_prompt.txt

          cat > user_prompt.txt << EOF
          PR Title: ${{ steps.pr.outputs.title }}
          PR Description: ${{ steps.pr.outputs.body }}

          Review the annotated diff below. Consider whether the changes match
          the stated intent, and pay special attention to edge cases and error
          handling in the new code.

          Annotated Diff:
          EOF
          cat annotated_diff.txt >> user_prompt.txt

          SYSTEM_JSON=$(jq -Rs . < system_prompt.txt)
          USER_JSON=$(jq -Rs . < user_prompt.txt)

          response=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"${{ inputs.model }}\",
              \"max_completion_tokens\": 4096,
              \"temperature\": 0.2,
              \"response_format\": {\"type\": \"json_object\"},
              \"messages\": [
                {\"role\": \"system\", \"content\": $SYSTEM_JSON},
                {\"role\": \"user\",   \"content\": $USER_JSON}
              ]
            }")

          echo "$response" > api_response.json

          if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
            error_msg=$(echo "$response" | jq -r '.error.message')
            echo "::error::OpenAI API error: $error_msg"
            printf '{"summary":"API Error: %s","inline_comments":[]}' "$error_msg" > review.json
            exit 0
          fi

          echo "$response" | jq -r '.choices[0].message.content // ""' > content_raw.txt

          echo "::group::Debug - Raw AI content (first 500 chars)"
          head -c 500 content_raw.txt
          echo ""
          echo "::endgroup::"

          if jq . content_raw.txt > /dev/null 2>&1; then
            cp content_raw.txt review.json
          else
            sed '/^```/d' content_raw.txt > content_cleaned.txt
            if jq . content_cleaned.txt > /dev/null 2>&1; then
              cp content_cleaned.txt review.json
            else
              echo "::warning::AI response was not valid JSON - falling back to plain comment"
              jq -n --arg s "$(cat content_raw.txt)" '{"summary": $s, "inline_comments": []}' > review.json
            fi
          fi

          if [ "${{ steps.pr.outputs.TRUNCATED }}" == "true" ]; then
            jq '.summary += "\n\n---\n**Note**: The diff was truncated due to size. This review covers the first ~50KB of changes."' \
              review.json > tmp.json && mv tmp.json review.json
          fi

          echo "::group::Debug - review.json structure"
          jq '{summary_length: (.summary | length), inline_comment_count: (.inline_comments | length), comments: [.inline_comments[] | {path, line}]}' review.json
          echo "::endgroup::"

      - name: Post review with inline comments
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          comment_count=$(jq '.inline_comments | length' review.json)
          echo "::notice::comment_count=$comment_count"

          if [ "$comment_count" -gt 0 ]; then
            # Convert AI's file line numbers to diff positions using position_map.json
            # The GitHub Reviews API reliably resolves "position" but not "line"/"side"
            jq --arg sha "${{ steps.pr.outputs.head_sha }}" \
               --slurpfile pmap position_map.json \
            '{
              body: .summary,
              event: "COMMENT",
              commit_id: $sha,
              comments: [
                .inline_comments[] |
                . as $c |
                ($c.path + ":" + ($c.line | tostring)) as $key |
                (if   $c.severity == "critical" then "ðŸš¨ **Critical**: "
                 elif $c.severity == "warning"  then "âš ï¸ **Warning**: "
                 elif $c.severity == "suggestion" then "ðŸš€ **Suggestion**: "
                 elif $c.severity == "nitpick"  then "âœ¨ **Nitpick**: "
                 else "" end) as $badge |
                if $pmap[0][$key] then
                  { path: $c.path, position: $pmap[0][$key], body: ($badge + $c.body) }
                else
                  empty
                end
              ]
            }' review.json > review_payload.json

            actual_count=$(jq '.comments | length' review_payload.json)
            echo "::notice::Comments after position mapping: $actual_count (dropped $(( comment_count - actual_count )) unresolvable)"

            echo "::group::Debug - review_payload.json"
            jq . review_payload.json
            echo "::endgroup::"

            if [ "$actual_count" -gt 0 ]; then
              echo "Submitting review with $actual_count inline comment(s)..."

              if gh api "repos/${{ github.repository }}/pulls/${{ inputs.pr_number }}/reviews" \
                   --method POST --input review_payload.json > review_result.json 2>&1; then
                echo "Review with inline comments posted to PR #${{ inputs.pr_number }}"
              else
                echo "::warning::Review API rejected comments"
                echo "::group::Debug - API rejection"
                cat review_result.json
                echo "::endgroup::"

                # Fallback to regular comment
                summary=$(jq -r '.summary' review.json)
                {
                  echo "$summary"
                  echo ""
                  echo "---"
                  echo "### Inline Comments"
                  echo ""
                  jq -r '.inline_comments[] | "- **`\(.path):\(.line)`** [\(.severity // "info")] \(.body)"' review.json
                } > fallback_comment.md
                gh pr comment ${{ inputs.pr_number }} --body-file fallback_comment.md
                echo "Review posted as regular comment (fallback) to PR #${{ inputs.pr_number }}"
              fi
            else
              echo "::warning::No comments survived position mapping - posting summary only"
              jq -r '.summary' review.json | gh pr comment ${{ inputs.pr_number }} --body-file -
              echo "Summary posted to PR #${{ inputs.pr_number }}"
            fi
          else
            jq -r '.summary' review.json | gh pr comment ${{ inputs.pr_number }} --body-file -
            echo "Summary posted to PR #${{ inputs.pr_number }}"
          fi

      - name: Upload review artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ai-review-openai-pr-${{ inputs.pr_number }}
          path: |
            review.json
            api_response.json
            annotated_diff.txt
            content_raw.txt
            position_map.json
            review_payload.json
          retention-days: 30
