name: AI PR Review (OpenAI)

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number
      model:
        description: 'OpenAI model to use'
        required: false
        default: 'gpt-5.2'
        type: choice
        options:
          - gpt-5.2
          - gpt-5-mini
          - gpt-4.1
          - o4-mini
          - o3

jobs:
  pr-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get PR details and diff
        id: pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          pr_data=$(gh pr view ${{ inputs.pr_number }} --json title,body,headRefOid)
          echo "title=$(echo "$pr_data" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "body=$(echo "$pr_data" | jq -r '.body // ""')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$pr_data" | jq -r '.headRefOid')" >> $GITHUB_OUTPUT

          gh pr diff ${{ inputs.pr_number }} > pr_diff.txt

          if [ $(wc -c < pr_diff.txt) -gt 50000 ]; then
            head -c 50000 pr_diff.txt > pr_diff_truncated.txt
            echo "TRUNCATED=true" >> $GITHUB_OUTPUT
            mv pr_diff_truncated.txt pr_diff.txt
          else
            echo "TRUNCATED=false" >> $GITHUB_OUTPUT
          fi

      - name: Annotate diff with file paths and line numbers
        run: |
          cat > annotate_diff.awk << 'AWKEOF'
          BEGIN { file = ""; nl = 0 }
          /^diff --git/ {
            n = split($0, parts, " ")
            file = parts[n]
            sub(/^b\//, "", file)
            next
          }
          /^(---|\+\+\+|index |old mode|new mode|similarity|rename|copy|new file|deleted file)/ { next }
          /^@@/ {
            s = $3
            sub(/\+/, "", s)
            sub(/,.*/, "", s)
            nl = int(s)
            print ""
            print "=== " file " ==="
            next
          }
          /^\+/ {
            printf "[%s:%d] %s\n", file, nl, $0
            nl++
            next
          }
          /^-/ {
            printf "[REMOVED] %s\n", $0
            next
          }
          {
            nl++
          }
          AWKEOF
          awk -f annotate_diff.awk pr_diff.txt > annotated_diff.txt

      - name: Run AI review
        id: review
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PR_TITLE: ${{ steps.pr.outputs.title }}
          PR_BODY: ${{ steps.pr.outputs.body }}
          MODEL: ${{ inputs.model }}
          TRUNCATED: ${{ steps.pr.outputs.TRUNCATED }}
        run: |
          node << 'NODESCRIPT'
          const fs = require("fs");
          const https = require("https");

          const SYSTEM_PROMPT = `You are an expert code reviewer. You will receive a pull request diff
          where each added/changed line is annotated as [filepath:line_number].

          Return your review as a single JSON object with this exact schema:

          {
            "summary": "<markdown-formatted overall review>",
            "inline_comments": [
              {
                "path": "relative/file/path.ext",
                "line": 0,
                "body": "Your specific, actionable comment"
              }
            ]
          }

          Rules:
          - "path" and "line" MUST exactly match values from the [filepath:line] annotations.
          - Only comment on added/changed lines (those with [filepath:line] annotations).
          - Keep inline comments specific, actionable, and concise.
          - Focus on: bugs, security issues, performance problems, correctness, and maintainability.
          - Do NOT add praise-only inline comments - only comment where there is something actionable.
          - If nothing warrants an inline comment, return an empty "inline_comments" array.
          - "summary" should cover: overview of changes, strengths, issues, suggestions, security, and testing.
          - Return ONLY the raw JSON object. No markdown fences. No surrounding text.`;

          const annotatedDiff = fs.readFileSync("annotated_diff.txt", "utf8");

          const userPrompt = `PR Title: ${process.env.PR_TITLE || ""}
          PR Description: ${process.env.PR_BODY || ""}

          Annotated Diff:
          ${annotatedDiff}`;

          const requestBody = JSON.stringify({
            model: process.env.MODEL,
            max_completion_tokens: 4096,
            temperature: 0.2,
            response_format: { type: "json_object" },
            messages: [
              { role: "system", content: SYSTEM_PROMPT },
              { role: "user", content: userPrompt },
            ],
          });

          const options = {
            hostname: "api.openai.com",
            path: "/v1/chat/completions",
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
              "Content-Length": Buffer.byteLength(requestBody),
            },
          };

          const req = https.request(options, (res) => {
            let data = "";
            res.on("data", (chunk) => (data += chunk));
            res.on("end", () => {
              fs.writeFileSync("api_response.json", data);

              let resp;
              try {
                resp = JSON.parse(data);
              } catch (e) {
                console.log("::error::Failed to parse API response as JSON");
                fs.writeFileSync("review.json", JSON.stringify({ summary: "Failed to parse API response", inline_comments: [] }));
                return;
              }

              if (resp.error) {
                console.log(`::error::OpenAI API error: ${resp.error.message}`);
                fs.writeFileSync("review.json", JSON.stringify({ summary: `API Error: ${resp.error.message}`, inline_comments: [] }));
                return;
              }

              const content = resp.choices?.[0]?.message?.content || "";

              console.log("::group::Debug - Raw AI content");
              console.log(content);
              console.log("::endgroup::");

              let review;
              try {
                review = JSON.parse(content);
              } catch (e) {
                // Try stripping code fences
                const cleaned = content.replace(/^```[\w]*\n?/gm, "").replace(/```$/gm, "");
                try {
                  review = JSON.parse(cleaned);
                } catch (e2) {
                  console.log("::warning::AI response was not valid JSON - falling back to plain comment");
                  review = { summary: content, inline_comments: [] };
                }
              }

              // Append truncation warning
              if (process.env.TRUNCATED === "true") {
                review.summary += "\n\n---\n**Note**: The diff was truncated due to size. This review covers the first ~50KB of changes.";
              }

              console.log("::group::Debug - review.json");
              console.log(JSON.stringify(review, null, 2));
              console.log("::endgroup::");
              console.log(`::notice::Inline comments found: ${(review.inline_comments || []).length}`);

              fs.writeFileSync("review.json", JSON.stringify(review));
            });
          });

          req.on("error", (e) => {
            console.log(`::error::Request failed: ${e.message}`);
            fs.writeFileSync("review.json", JSON.stringify({ summary: `Request failed: ${e.message}`, inline_comments: [] }));
          });

          req.write(requestBody);
          req.end();
          NODESCRIPT

      - name: Post review with inline comments
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          summary=$(jq -r '.summary' review.json)
          comment_count=$(jq '.inline_comments | length' review.json)

          echo "::notice::comment_count=$comment_count, head_sha=${{ steps.pr.outputs.head_sha }}"

          if [ "$comment_count" -gt 0 ]; then
            jq --arg sha "${{ steps.pr.outputs.head_sha }}" '{
              body: .summary,
              event: "COMMENT",
              commit_id: $sha,
              comments: [.inline_comments[] | {path, line, body, side: "RIGHT"}]
            }' review.json > review_payload.json

            echo "::group::Debug - review_payload.json"
            jq . review_payload.json
            echo "::endgroup::"

            echo "Submitting review with $comment_count inline comment(s)..."

            if gh api "repos/${{ github.repository }}/pulls/${{ inputs.pr_number }}/reviews" \
                 --method POST --input review_payload.json > review_result.json 2>&1; then
              echo "Review with inline comments posted to PR #${{ inputs.pr_number }}"
            else
              echo "::warning::Inline comments rejected by GitHub API - posting as regular comment"
              echo "::group::Debug - API rejection"
              cat review_result.json
              echo "::endgroup::"

              {
                echo "$summary"
                echo ""
                echo "---"
                echo "### Inline Comments"
                echo ""
                jq -r '.inline_comments[] | "- **`\(.path):\(.line)`** - \(.body)"' review.json
              } > fallback_comment.md

              gh pr comment ${{ inputs.pr_number }} --body-file fallback_comment.md
              echo "Review posted as regular comment (fallback) to PR #${{ inputs.pr_number }}"
            fi
          else
            echo "$summary" | gh pr comment ${{ inputs.pr_number }} --body-file -
            echo "Summary posted to PR #${{ inputs.pr_number }}"
          fi

      - name: Upload review artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ai-review-openai-pr-${{ inputs.pr_number }}
          path: |
            review.json
            api_response.json
            annotated_diff.txt
          retention-days: 30
