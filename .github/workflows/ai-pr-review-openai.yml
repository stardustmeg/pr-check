name: AI PR Review (OpenAI)

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number
      model:
        description: 'OpenAI model to use'
        required: false
        default: 'gpt-4.1'
        type: choice
        options:
          - gpt-5.2
          - gpt-5-mini
          - gpt-4.1
          - o4-mini
          - o3

jobs:
  pr-review:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get PR details and diff
        id: pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          pr_data=$(gh pr view ${{ inputs.pr_number }} --json title,body,headRefOid)
          echo "title=$(echo "$pr_data" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "body=$(echo "$pr_data" | jq -r '.body // ""')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$pr_data" | jq -r '.headRefOid')" >> $GITHUB_OUTPUT

          gh pr diff ${{ inputs.pr_number }} > pr_diff.txt

          if [ $(wc -c < pr_diff.txt) -gt 50000 ]; then
            head -c 50000 pr_diff.txt > pr_diff_truncated.txt
            echo "TRUNCATED=true" >> $GITHUB_OUTPUT
            mv pr_diff_truncated.txt pr_diff.txt
          else
            echo "TRUNCATED=false" >> $GITHUB_OUTPUT
          fi

      - name: Annotate diff with file paths, line numbers, and diff positions
        run: |
          # This awk script produces two outputs:
          # 1. annotated_diff.txt  - for the AI to read (human-friendly)
          # 2. position_map.json   - maps "file:line" -> diff position for the GitHub API
          #
          # GitHub's Reviews API uses "position" (1-based offset from the @@ header,
          # continuing across hunks per file). The "line"/"side" params are unreliable.
          cat > annotate_diff.awk << 'AWKEOF'
          BEGIN {
            file = ""; nl = 0; pos = 0
            printf "{" > "position_map.json"
            first = 1
          }
          /^diff --git/ {
            n = split($0, parts, " ")
            file = parts[n]
            sub(/^b\//, "", file)
            pos = 0
            next
          }
          /^(---|\+\+\+|index |old mode|new mode|similarity|rename|copy|new file|deleted file)/ { next }
          /^@@/ {
            s = $3
            sub(/\+/, "", s)
            sub(/,.*/, "", s)
            nl = int(s)
            print ""
            print "=== " file " ==="
            next
          }
          /^\+/ {
            pos++
            printf "[%s:%d pos:%d] %s\n", file, nl, pos, $0
            # Write to position map
            key = file ":" nl
            if (!first) printf "," >> "position_map.json"
            printf "\"%s\":%d", key, pos >> "position_map.json"
            first = 0
            nl++
            next
          }
          /^-/ {
            pos++
            printf "[REMOVED pos:%d] %s\n", pos, $0
            next
          }
          {
            # Context line
            pos++
            nl++
          }
          END {
            printf "}" >> "position_map.json"
          }
          AWKEOF
          awk -f annotate_diff.awk pr_diff.txt > annotated_diff.txt

          echo "::group::Debug - position_map.json"
          cat position_map.json | jq .
          echo "::endgroup::"

      - name: Run AI review
        id: review
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cat > system_prompt.txt << 'SYSPROMPT'
          You are an expert code reviewer. You will receive a pull request diff
          where each added/changed line is annotated as [filepath:line_number pos:N].

          Return your review as a single JSON object with this exact schema:

          {
            "summary": "<markdown-formatted overall review>",
            "inline_comments": [
              {
                "path": "relative/file/path.ext",
                "line": <integer - must match a line_number from annotations>,
                "body": "Your specific, actionable comment"
              }
            ]
          }

          Rules:
          - "path" and "line" MUST exactly match values from the [filepath:line_number] annotations.
          - Only comment on added/changed lines (those with annotations).
          - Keep inline comments specific, actionable, and concise.
          - Focus on: bugs, security issues, performance problems, correctness, and maintainability.
          - Do NOT add praise-only inline comments - only comment where there is something actionable.
          - If nothing warrants an inline comment, return an empty "inline_comments" array.
          - "summary" should cover: overview of changes, strengths, issues, suggestions, security, and testing.
          - Return ONLY the raw JSON object. No markdown fences. No surrounding text.
          SYSPROMPT

          cat > user_prompt.txt << EOF
          PR Title: ${{ steps.pr.outputs.title }}
          PR Description: ${{ steps.pr.outputs.body }}

          Annotated Diff:
          EOF
          cat annotated_diff.txt >> user_prompt.txt

          SYSTEM_JSON=$(jq -Rs . < system_prompt.txt)
          USER_JSON=$(jq -Rs . < user_prompt.txt)

          response=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"${{ inputs.model }}\",
              \"max_completion_tokens\": 4096,
              \"temperature\": 0.2,
              \"response_format\": {\"type\": \"json_object\"},
              \"messages\": [
                {\"role\": \"system\", \"content\": $SYSTEM_JSON},
                {\"role\": \"user\",   \"content\": $USER_JSON}
              ]
            }")

          echo "$response" > api_response.json

          if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
            error_msg=$(echo "$response" | jq -r '.error.message')
            echo "::error::OpenAI API error: $error_msg"
            printf '{"summary":"API Error: %s","inline_comments":[]}' "$error_msg" > review.json
            exit 0
          fi

          echo "$response" | jq -r '.choices[0].message.content // ""' > content_raw.txt

          echo "::group::Debug - Raw AI content (first 500 chars)"
          head -c 500 content_raw.txt
          echo ""
          echo "::endgroup::"

          if jq . content_raw.txt > /dev/null 2>&1; then
            cp content_raw.txt review.json
          else
            sed '/^```/d' content_raw.txt > content_cleaned.txt
            if jq . content_cleaned.txt > /dev/null 2>&1; then
              cp content_cleaned.txt review.json
            else
              echo "::warning::AI response was not valid JSON - falling back to plain comment"
              jq -n --arg s "$(cat content_raw.txt)" '{"summary": $s, "inline_comments": []}' > review.json
            fi
          fi

          if [ "${{ steps.pr.outputs.TRUNCATED }}" == "true" ]; then
            jq '.summary += "\n\n---\n**Note**: The diff was truncated due to size. This review covers the first ~50KB of changes."' \
              review.json > tmp.json && mv tmp.json review.json
          fi

          echo "::group::Debug - review.json structure"
          jq '{summary_length: (.summary | length), inline_comment_count: (.inline_comments | length), comments: [.inline_comments[] | {path, line}]}' review.json
          echo "::endgroup::"

      - name: Post review with inline comments
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          comment_count=$(jq '.inline_comments | length' review.json)
          echo "::notice::comment_count=$comment_count"

          if [ "$comment_count" -gt 0 ]; then
            # Convert AI's file line numbers to diff positions using position_map.json
            # The GitHub Reviews API reliably resolves "position" but not "line"/"side"
            jq --arg sha "${{ steps.pr.outputs.head_sha }}" \
               --slurpfile pmap position_map.json \
            '{
              body: .summary,
              event: "COMMENT",
              commit_id: $sha,
              comments: [
                .inline_comments[] |
                . as $c |
                ($c.path + ":" + ($c.line | tostring)) as $key |
                if $pmap[0][$key] then
                  { path: $c.path, position: $pmap[0][$key], body: $c.body }
                else
                  empty
                end
              ]
            }' review.json > review_payload.json

            actual_count=$(jq '.comments | length' review_payload.json)
            echo "::notice::Comments after position mapping: $actual_count (dropped $(( comment_count - actual_count )) unresolvable)"

            echo "::group::Debug - review_payload.json"
            jq . review_payload.json
            echo "::endgroup::"

            if [ "$actual_count" -gt 0 ]; then
              echo "Submitting review with $actual_count inline comment(s)..."

              if gh api "repos/${{ github.repository }}/pulls/${{ inputs.pr_number }}/reviews" \
                   --method POST --input review_payload.json > review_result.json 2>&1; then
                echo "Review with inline comments posted to PR #${{ inputs.pr_number }}"
              else
                echo "::warning::Review API rejected comments"
                echo "::group::Debug - API rejection"
                cat review_result.json
                echo "::endgroup::"

                # Fallback to regular comment
                summary=$(jq -r '.summary' review.json)
                {
                  echo "$summary"
                  echo ""
                  echo "---"
                  echo "### Inline Comments"
                  echo ""
                  jq -r '.inline_comments[] | "- **`\(.path):\(.line)`** - \(.body)"' review.json
                } > fallback_comment.md
                gh pr comment ${{ inputs.pr_number }} --body-file fallback_comment.md
                echo "Review posted as regular comment (fallback) to PR #${{ inputs.pr_number }}"
              fi
            else
              echo "::warning::No comments survived position mapping - posting summary only"
              jq -r '.summary' review.json | gh pr comment ${{ inputs.pr_number }} --body-file -
              echo "Summary posted to PR #${{ inputs.pr_number }}"
            fi
          else
            jq -r '.summary' review.json | gh pr comment ${{ inputs.pr_number }} --body-file -
            echo "Summary posted to PR #${{ inputs.pr_number }}"
          fi

      - name: Upload review artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ai-review-openai-pr-${{ inputs.pr_number }}
          path: |
            review.json
            api_response.json
            annotated_diff.txt
            content_raw.txt
            position_map.json
            review_payload.json
          retention-days: 30
